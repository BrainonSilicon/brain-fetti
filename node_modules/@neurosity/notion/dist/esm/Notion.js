var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Observable, throwError, timer } from "rxjs";
import { map } from "rxjs/operators";
import { ApiClient, credentialWithLink, createUser } from "./api/index";
import { getLabels, validate } from "./utils/subscription";
/**
 * Example
 * ```typescript
 * import { Notion } from "@neurosity/notion";
 *
 * const notion = new Notion({
 *   deviceId: "..."
 * });
 * ```
 */
export class Notion {
    /**
     * Creates new instance of Notion
     *
     * ```typescript
     * const notion = new Notion({
     *   deviceId: "..."
     * });
     * ```
  
     * @param options
     */
    constructor(options) {
        /**
         * @internal
         * Not user facing
         */
        this.getMetric = (subscription) => {
            const { metric, labels, atomic } = subscription;
            const error = validate(metric, labels, this.options);
            if (error) {
                return throwError(error);
            }
            return new Observable(observer => {
                const subscriptions = atomic
                    ? [
                        this.api.metrics.subscribe({
                            metric: metric,
                            labels: labels,
                            atomic: atomic
                        })
                    ]
                    : labels.map(label => {
                        return this.api.metrics.subscribe({
                            metric: metric,
                            labels: [label],
                            atomic: atomic
                        });
                    });
                const subscriptionWithListeners = subscriptions.map(subscription => ({
                    subscription,
                    listener: this.api.metrics.on(subscription, (...data) => {
                        observer.next(...data);
                    })
                }));
                return () => {
                    subscriptionWithListeners.forEach(({ subscription, listener }) => {
                        this.api.metrics.unsubscribe(subscription, listener);
                    });
                };
            });
        };
        this.options = Object.freeze(options);
        this.api = new ApiClient(this.options);
        if (!this.options.deviceId) {
            throw new Error("Notion: deviceId is mandatory");
        }
    }
    /**
     * Starts user session
     *
     * ```typescript
     * await notion.login({
     *   email: "...",
     *   password: "..."
     * });
     * ```
     *
     * @param credentials
     */
    login(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.login(credentials);
        });
    }
    /**
     * Ends user session
     *
     * ```typescript
     * await notion.logout();
     * // session has ended
     * ```
     *
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.logout();
        });
    }
    /**
     * @internal
     * Not user facing yet
     */
    auth() {
        return this.api.auth();
    }
    /**
     * @internal
     * Not user facing yet
     */
    onAuthStateChanged() {
        return this.api.onAuthStateChanged();
    }
    /**
     * ```typescript
     * const info = await notion.getInfo();
     * ```
     */
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.getInfo();
        });
    }
    /**
     * Ends database connection
     *
     * ```typescript
     * await notion.disconnect();
     * ```
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.api.disconnect();
        });
    }
    /**
     * @internal
     * Not user facing
     */
    dispatchAction(action) {
        return this.api.actions.dispatch(action);
    }
    /**
     * Injects an EEG marker to data stream
     *
     * ```typescript
     * notion.addMarker("eyes-closed");
     *
     * // later...
     *
     * notion.addMarker("eyes-open");
     * ```
     *
     * @param label Name the label to inject
     */
    addMarker(label) {
        if (!label) {
            throw new Error("Notion: a label is required for addMarker");
        }
        this.dispatchAction({
            command: "marker",
            action: "add",
            message: {
                label,
                timestamp: this.api.timestamp
            }
        });
    }
    /**
     * @internal
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of awareness metric events
     */
    awareness(label, ...otherLabels) {
        return this.getMetric({
            metric: "awareness",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     *
     * Example
     * ```typescript
     * notion.brainwaves("raw").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Example
     * ```typescript
     * notion.brainwaves("powerByBand").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * Example
     * ```typescript
     * notion.brainwaves("psd").subscribe(brainwaves => {
     *   console.log(brainwaves);
     * });
     * ```
     *
     * @param labels Name of metric properties to filter by
     * @returns Observable of brainwaves metric events
     */
    brainwaves(label, ...otherLabels) {
        return this.getMetric({
            metric: "brainwaves",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Example
     * ```typescript
     * notion.calm().subscribe(calm => {
     *   console.log(calm.probability);
     * });
     *
     * // 0.45
     * // 0.47
     * // 0.53
     * // 0.51
     * // ...
     * ```
     *
     * @returns Observable of calm events - awareness/calm alias
     */
    calm() {
        return this.awareness("calm");
    }
    /**
     * Observes signal quality data where each property is the name
     * of the channel and the value includes the standard deviation and
     * a status set by the device
     *
     * ```typescript
     * notion.signalQuality().subscribe(signalQuality => {
     *   console.log(signalQuality);
     * });
     *
     * // { FC6: { standardDeviation: 3.5, status: "good" }, C3: {...}, ... }
     * ```
     *
     * @returns Observable of signalQuality metric events
     */
    signalQuality() {
        const metric = "signalQuality";
        return this.getMetric({
            metric,
            labels: getLabels(metric),
            atomic: true
        });
    }
    /**
     * @internal
     * Proof of Concept for `emotion` - Not user facing yet
     *
     * @returns Observable of emotion metric events
     */
    emotion(label, ...otherLabels) {
        return this.getMetric({
            metric: "emotion",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Observes last state of `settings` and all subsequent `settings` changes
     *
     * ```typescript
     * notion.settings().subscribe(settings => {
     *   console.log(settings.lsl);
     * });
     *
     * // true
     * // ...
     * ```
     *
     * @returns Observable of `settings` metric events
     */
    settings() {
        const namespace = "settings";
        return new Observable(observer => {
            const listener = this.api.onNamespace(namespace, (settings) => {
                observer.next(settings);
            });
            return () => this.api.offNamespace(namespace, listener);
        });
    }
    /**
     * Example
     * ```typescript
     * notion.focus().subscribe(focus => {
     *   console.log(focus.probability);
     * });
     *
     * // 0.56
     * // 0.46
     * // 0.31
     * // 0.39
     * // ...
     * ```
     *
     * @returns Observable of focus events - awareness/focus alias
     */
    focus() {
        return this.awareness("focus");
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of kinesis metric events
     */
    kinesis(label, ...otherLabels) {
        return this.getMetric({
            metric: "kinesis",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * @param labels Name of metric properties to filter by
     * @returns Observable of predictions metric events
     */
    predictions(label, ...otherLabels) {
        return this.getMetric({
            metric: "predictions",
            labels: label ? [label, ...otherLabels] : [],
            atomic: false
        });
    }
    /**
     * Observes last state of `status` and all subsequent `status` changes
     *
     * ```typescript
     * notion.status().subscribe(status => {
     *   console.log(status.state);
     * });
     *
     * // "online"
     * // ...
     * ```
     *
     * @returns Observable of `status` metric events
     */
    status() {
        const namespace = "status";
        const updateStatusInterval = 1000;
        return new Observable(observer => {
            const updateStatusSubscription = timer(0, updateStatusInterval).subscribe(i => {
                this.api
                    .httpsCallable("updateDeviceStatus", {
                    deviceId: this.options.deviceId
                })
                    .catch(console.error);
            });
            const listener = this.api.onNamespace(namespace, status => {
                observer.next(status);
            });
            return () => {
                updateStatusSubscription.unsubscribe();
                this.api.offNamespace(namespace, listener);
            };
        });
    }
    /**
     * @internal
     * Not user facing yet
     *
     * Changes device settings programatically. These settings can be
     * also changed from the developer console under device settings.
     *
     * Available settings [[ChangeSettings]]
     *
     * Example
     * ```typescript
     * notion.changeSettings({
     *   lsl: true
     * });
     * ```
     */
    changeSettings(settings) {
        return this.api.changeSettings(settings);
    }
    /**
     *
     * ```typescript
     * notion.training.record({
     *   metric: "kinesis",
     *   label: "push"
     * });
     *
     * notion.training.stop({
     *   metric: "kinesis",
     *   label: "push"
     * });
     * ```
     *
     * @returns Training methods
     */
    get training() {
        return {
            /**
             * Records a training for a metric/label pair
             * @category Training
             */
            record: training => {
                const userId = this.api.user && "uid" in this.api.user
                    ? this.api.user.uid
                    : null;
                const message = Object.assign(Object.assign({ fit: false, baseline: false, timestamp: this.api.timestamp }, training), { userId });
                this.api.actions.dispatch({
                    command: "training",
                    action: "record",
                    message
                });
            },
            /**
             * Stops the training for a metric/label pair
             * @category Training
             */
            stop: training => {
                this.api.actions.dispatch({
                    command: "training",
                    action: "stop",
                    message: Object.assign({}, training)
                });
            },
            /**
             * Stops all trainings
             * @category Training
             */
            stopAll: () => {
                this.api.actions.dispatch({
                    command: "training",
                    action: "stopAll",
                    message: {}
                });
            }
        };
    }
    /**
     * @internal
     * Proof of Concept for Skills - Not user facing yet
     *
     * Accesses a skill by Bundle ID. Additionally, allows to observe
     * and push skill metrics
     *
     * @param bundleId Bundle ID of skill
     * @returns Skill isntance
     */
    skill(bundleId) {
        return __awaiter(this, void 0, void 0, function* () {
            const skillData = yield this.api.skills.get(bundleId);
            if (skillData === null) {
                return Promise.reject(new Error(`Access denied for: ${bundleId}. Make sure the skill is installed.`));
            }
            return {
                metric: (label) => {
                    const metricName = `skill~${skillData.id}~${label}`;
                    const subscription = new Observable(observer => {
                        const subscription = this.api.metrics.subscribe({
                            metric: metricName,
                            labels: [label],
                            atomic: true
                        });
                        const listener = this.api.metrics.on(subscription, (...data) => {
                            observer.next(...data);
                        });
                        return () => {
                            this.api.metrics.unsubscribe(subscription, listener);
                        };
                    }).pipe(map(metric => metric[label]));
                    Object.defineProperty(subscription, "next", {
                        value: (metricValue) => {
                            this.api.metrics.next(metricName, {
                                [label]: metricValue
                            });
                        }
                    });
                    return subscription;
                }
            };
        });
    }
}
/**
 *
 * @hidden
 */
Notion.credentialWithLink = credentialWithLink;
/**
 *
 * @hidden
 */
Notion.createUser = createUser;
