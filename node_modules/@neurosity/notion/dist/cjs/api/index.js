"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ipk_1 = require("@neurosity/ipk");
const index_1 = require("./firebase/index");
const websocket_1 = require("./websocket");
const timesync_1 = require("../timesync");
const isNotionMetric = (metric) => Object.keys(ipk_1.metrics).includes(metric);
var firebase_1 = require("./firebase");
exports.credentialWithLink = firebase_1.credentialWithLink;
exports.createUser = firebase_1.createUser;
/**
 * @hidden
 */
class ApiClient {
    constructor(options) {
        this.options = options;
        this.firebase = new index_1.FirebaseClient(options);
        this.firebase.onAuthStateChanged().subscribe(user => {
            this.user = user;
        });
        if (this.options.timesync) {
            this.firebase.onLogin().subscribe(() => {
                this.timesync = new timesync_1.Timesync({
                    getTimesync: this.firebase.getTimesync.bind(this.firebase)
                });
            });
        }
        if (options.onDeviceSocketUrl) {
            this.onDeviceSocket = new websocket_1.WebsocketClient({
                deviceId: options.deviceId,
                socketUrl: options.onDeviceSocketUrl
            });
        }
    }
    get actions() {
        return {
            dispatch: action => {
                return this.firebase.dispatchAction(action);
            }
        };
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.onDeviceSocket) {
                this.onDeviceSocket.disconnect();
            }
            return this.firebase.disconnect();
        });
    }
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.firebase.getInfo();
        });
    }
    login(credentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.firebase.login(credentials);
            return user;
        });
    }
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.firebase.logout();
        });
    }
    auth() {
        return this.firebase.auth();
    }
    onAuthStateChanged() {
        return this.firebase.onAuthStateChanged();
    }
    onNamespace(namespace, callback) {
        return this.firebase.onNamespace(namespace, callback);
    }
    offNamespace(namespace, listener) {
        this.firebase.offNamespace(namespace, listener);
    }
    get metrics() {
        const shouldRerouteToDevice = (metric) => this.onDeviceSocket && isNotionMetric(metric);
        return {
            next: (metricName, metricValue) => {
                this.firebase.nextMetric(metricName, metricValue);
            },
            on: (subscription, callback) => {
                if (shouldRerouteToDevice(subscription.metric)) {
                    return this.onDeviceSocket.onMetric(subscription, callback);
                }
                else {
                    return this.firebase.onMetric(subscription, callback);
                }
            },
            subscribe: subscription => {
                const serverType = shouldRerouteToDevice(subscription.metric)
                    ? this.onDeviceSocket.serverType
                    : this.firebase.serverType;
                const subscriptionCreated = this.firebase.subscribeToMetric(Object.assign(Object.assign({}, subscription), { serverType }));
                return subscriptionCreated;
            },
            unsubscribe: (subscription, listener) => {
                this.firebase.unsubscribFromMetric(subscription, listener);
            }
        };
    }
    httpsCallable(functionName, data) {
        return this.firebase.httpsCallable(functionName, data);
    }
    get skills() {
        return {
            get: (bundleId) => __awaiter(this, void 0, void 0, function* () {
                return this.firebase.getSkill(bundleId);
            })
        };
    }
    get timestamp() {
        return this.options.timesync ? this.timesync.timestamp : Date.now();
    }
    changeSettings(settings) {
        return this.firebase.changeSettings(settings);
    }
}
exports.ApiClient = ApiClient;
