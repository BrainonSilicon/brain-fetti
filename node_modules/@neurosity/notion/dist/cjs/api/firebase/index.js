"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const app_1 = __importDefault(require("firebase/app"));
require("firebase/database");
require("firebase/functions");
require("firebase/auth");
const config_1 = require("./config");
const deviceStore_1 = require("./deviceStore");
const SERVER_TIMESTAMP = app_1.default.database.ServerValue.TIMESTAMP;
/**
 * @hidden
 */
exports.credentialWithLink = app_1.default.auth.EmailAuthProvider.credentialWithLink;
/**
 * @hidden
 */
function createUser(...args) {
    return new app_1.default.User(...args);
}
exports.createUser = createUser;
/**
 * @hidden
 */
class FirebaseClient {
    constructor(options) {
        this.serverType = "firebase";
        this.init(options);
    }
    init(options) {
        this.app = this.getApp(options.deviceId);
        this.standalone = this.app.name === options.deviceId;
        this.deviceStore = deviceStore_1.createDeviceStore(this.app, options.deviceId, SERVER_TIMESTAMP);
        this.app.auth().onAuthStateChanged((user) => {
            this.user = user;
        });
    }
    auth() {
        return this.app.auth();
    }
    onAuthStateChanged() {
        return new rxjs_1.Observable(observer => {
            this.app.auth().onAuthStateChanged((user) => {
                observer.next(user);
            });
        });
    }
    onLogin() {
        return new rxjs_1.Observable(observer => {
            const unsubscribe = this.app
                .auth()
                .onAuthStateChanged((user) => {
                if (!!user) {
                    observer.next(user);
                    observer.complete();
                }
            });
            return () => unsubscribe();
        });
    }
    login(credentials) {
        if ("idToken" in credentials && "providerId" in credentials) {
            const provider = new app_1.default.auth.OAuthProvider(credentials.providerId);
            const oAuthCredential = provider.credential(credentials.idToken);
            return this.app.auth().signInWithCredential(oAuthCredential);
        }
        if ("email" in credentials && "password" in credentials) {
            const { email, password } = credentials;
            return this.app
                .auth()
                .signInWithEmailAndPassword(email, password);
        }
        throw new Error(`Either email/password or an idToken/providerId is required`);
    }
    logout() {
        return this.app.auth().signOut();
    }
    getApp(deviceId) {
        const notionAppName = deviceId;
        const moduleApps = app_1.default.apps;
        const browserApps = typeof window !== "undefined" &&
            "firebase" in window &&
            "apps" in window.firebase
            ? window.firebase.apps
            : [];
        const neurosityApp = [...moduleApps, ...browserApps].find((app) => app.name === "[DEFAULT]" &&
            app.options.databaseURL === config_1.config.databaseURL);
        if (neurosityApp) {
            return neurosityApp;
        }
        const notionApp = moduleApps.find(app => app.name === notionAppName);
        return notionApp
            ? notionApp
            : app_1.default.initializeApp(config_1.config, notionAppName);
    }
    dispatchAction(action) {
        return this.deviceStore.dispatchAction(action);
    }
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.deviceStore.once("info");
        });
    }
    getSkill(bundleId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.deviceStore.lastOfChildValue("skills", "bundleId", bundleId);
        });
    }
    onNamespace(namespace, callback) {
        return this.deviceStore.onNamespace(namespace, callback);
    }
    offNamespace(namespace, listener) {
        this.deviceStore.offNamespace(namespace, listener);
    }
    getTimesync() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.dispatchAction({
                command: "timesync",
                action: "get",
                responseRequired: true,
                responseTimeout: 250
            });
            return response.timestamp;
        });
    }
    httpsCallable(functionName, data) {
        return this.app.functions().httpsCallable(functionName)(data);
    }
    /**
     * Pushes metric for each subscriptions in path:
     * /devices/:deviceId/metrics/:metricName
     */
    nextMetric(metricName, metricValue) {
        this.deviceStore.nextMetric(metricName, metricValue);
    }
    /**
     * Listens for metrics in path:
     * /devices/:deviceId/metrics/:metricName
     */
    onMetric(subscription, callback) {
        this.deviceStore.onMetric(subscription, callback);
    }
    /**
     * Creates a new and unique subscription in path:
     * /devices/:deviceId/subscriptions/:subscriptionId
     * E.g. /devices/device1/subscriptions/subscription3
     *
     * @param subscription
     * @returns subscriptionId
     */
    subscribeToMetric(subscription) {
        const subscriptionId = this.deviceStore.subscribeToMetric(subscription);
        return subscriptionId;
    }
    /**
     * Removes subscription in path:
     * /devices/:deviceId/subscriptions/:subscriptionId
     *
     * @param metric
     * @param subscriptionId
     */
    unsubscribFromMetric(subscription, listener) {
        this.deviceStore.unsubscribFromMetric(subscription, listener);
    }
    get timestamp() {
        return SERVER_TIMESTAMP;
    }
    changeSettings(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.deviceStore.update("settings", settings);
        });
    }
    disconnect() {
        if (this.standalone) {
            return this.app.delete();
        }
        return Promise.resolve();
    }
}
exports.FirebaseClient = FirebaseClient;
