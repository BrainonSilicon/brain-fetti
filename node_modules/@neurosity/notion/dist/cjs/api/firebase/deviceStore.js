"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @hidden
 */
exports.createDeviceStore = (app, deviceId, SERVER_TIMESTAMP) => {
    const deviceRef = app.database().ref(`devices/${deviceId}`);
    const clientId = deviceRef.child("subscriptions").push().key;
    const clientRef = deviceRef.child(`clients/${clientId}`);
    // Add client connections to db and remove them when offline
    app
        .database()
        .ref(".info/connected")
        .on("value", snapshot => {
        if (!snapshot.val()) {
            return;
        }
        clientRef
            .onDisconnect()
            .remove()
            .then(() => {
            clientRef.set(SERVER_TIMESTAMP);
        });
    });
    const child = namespace => {
        return deviceRef.child(namespace);
    };
    const set = (namespace, payload) => {
        return deviceRef.child(namespace).set(payload);
    };
    const push = (namespace, payload) => {
        return deviceRef.child(namespace).push(payload);
    };
    const update = (namespace, payload) => {
        deviceRef.child(namespace).update(payload);
    };
    const on = (eventType = "value", namespace, callback) => {
        return deviceRef.child(namespace).on(eventType, snapshot => {
            callback(snapshot.val(), snapshot);
        });
    };
    const off = (childName, eventType, listener) => {
        if (listener) {
            deviceRef.child(childName).off(eventType, listener);
        }
        else {
            deviceRef.child(childName).off(eventType);
        }
    };
    const once = (namespace, eventType = "value") => __awaiter(void 0, void 0, void 0, function* () {
        const snapshot = yield deviceRef.child(namespace).once(eventType);
        return snapshot.val();
    });
    const remove = namespace => {
        deviceRef.child(namespace).remove();
    };
    const bindListener = (eventType, namespace, callback, overrideResponse) => {
        on(eventType, namespace, data => {
            if (data !== null) {
                off(namespace, eventType);
                const response = overrideResponse ? overrideResponse : data;
                callback(response);
            }
        });
    };
    const lastOfChildValue = (namespace, key, value) => __awaiter(void 0, void 0, void 0, function* () {
        const snapshot = yield deviceRef
            .child(namespace)
            .orderByChild(key)
            .equalTo(value)
            .limitToLast(1)
            .once("value");
        const results = snapshot.val();
        const [match] = Object.values(results || {});
        return match || null;
    });
    return {
        set,
        once,
        update,
        lastOfChildValue,
        onNamespace: (namespace, callback) => {
            return on("value", namespace, (data) => {
                if (data !== null) {
                    callback(data);
                }
            });
        },
        offNamespace: (namespace, listener) => {
            off(namespace, "value", listener);
        },
        dispatchAction: (action) => __awaiter(void 0, void 0, void 0, function* () {
            const snapshot = yield push("actions", action);
            const actionId = snapshot.key;
            const actionPath = `actions/${actionId}`;
            snapshot.onDisconnect().remove();
            if (action.responseRequired) {
                const responseTimeout = action.responseTimeout || 600000; // defaults to 10 minutes
                const timeout = new Promise((_, reject) => {
                    const id = setTimeout(() => {
                        clearTimeout(id);
                        snapshot.remove();
                        reject(`Action response timed out in ${responseTimeout}ms.`);
                    }, responseTimeout);
                });
                const response = new Promise(resolve => {
                    bindListener("value", `${actionPath}/response`, resolve);
                });
                return Promise.race([response, timeout]);
            }
            return actionId;
        }),
        nextMetric: (metricName, metricValue) => __awaiter(void 0, void 0, void 0, function* () {
            set(`metrics/${metricName}`, metricValue);
        }),
        onMetric: (subscription, callback) => {
            const { atomic, metric, labels } = subscription;
            const child = atomic
                ? `metrics/${metric}`
                : `metrics/${metric}/${labels[0]}`;
            return on("value", child, data => {
                if (data !== null) {
                    callback(data);
                }
            });
        },
        subscribeToMetric: subscription => {
            const id = deviceRef.child("subscriptions").push().key;
            const childPath = `subscriptions/${id}`;
            const subscriptionCreated = Object.assign({ id,
                clientId }, subscription);
            set(childPath, subscriptionCreated);
            deviceRef
                .child(childPath)
                .onDisconnect()
                .remove();
            return subscriptionCreated;
        },
        unsubscribFromMetric: (subscription, listener) => {
            off("value", listener);
            remove(`subscriptions/${subscription.id}`);
        }
    };
};
