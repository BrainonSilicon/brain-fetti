{"version":3,"sources":["api/firebase/config.ts","api/firebase/deviceStore.ts","api/firebase/index.ts","api/websocket/index.ts","timesync/Timesync.ts","timesync/index.ts","api/index.ts","utils/subscription.ts","Notion.ts","skills/NotionOnDevice.ts","skills/createSkill.ts","skills/index.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../../src","sourcesContent":["export const config = {\n  apiKey: \"AIzaSyB0TkZ83Fj0CIzn8AAmE-Osc92s3ER8hy8\",\n  authDomain: \"neurosity-device.firebaseapp.com\",\n  databaseURL: \"https://neurosity-device.firebaseio.com\",\n  projectId: \"neurosity-device\",\n  storageBucket: \"neurosity-device.appspot.com\",\n  messagingSenderId: \"212595049674\"\n};\n","export interface IDevice {\n  info: any;\n  status: any;\n  subscriptions: any;\n  metrics: any;\n}\n\n/**\n * @hidden\n */\nexport const createDeviceStore = (app, deviceId, SERVER_TIMESTAMP) => {\n  const deviceRef = app.database().ref(`devices/${deviceId}`);\n  const clientId = deviceRef.child(\"subscriptions\").push().key;\n  const clientRef = deviceRef.child(`clients/${clientId}`);\n\n  // Add client connections to db and remove them when offline\n  app\n    .database()\n    .ref(\".info/connected\")\n    .on(\"value\", snapshot => {\n      if (!snapshot.val()) {\n        return;\n      }\n\n      clientRef\n        .onDisconnect()\n        .remove()\n        .then(() => {\n          clientRef.set(SERVER_TIMESTAMP);\n        });\n    });\n\n  const child = namespace => {\n    return deviceRef.child(namespace);\n  };\n\n  const set = (namespace, payload) => {\n    return deviceRef.child(namespace).set(payload);\n  };\n\n  const push = (namespace, payload) => {\n    return deviceRef.child(namespace).push(payload);\n  };\n\n  const update = (namespace, payload) => {\n    deviceRef.child(namespace).update(payload);\n  };\n\n  const on = (eventType: any = \"value\", namespace, callback) => {\n    return deviceRef.child(namespace).on(eventType, snapshot => {\n      callback(snapshot.val(), snapshot);\n    });\n  };\n\n  const off = (childName, eventType, listener?) => {\n    if (listener) {\n      deviceRef.child(childName).off(eventType, listener);\n    } else {\n      deviceRef.child(childName).off(eventType);\n    }\n  };\n\n  const once = async (namespace, eventType = \"value\") => {\n    const snapshot = await deviceRef.child(namespace).once(eventType);\n    return snapshot.val();\n  };\n\n  const remove = namespace => {\n    deviceRef.child(namespace).remove();\n  };\n\n  const bindListener = (\n    eventType: string,\n    namespace: string,\n    callback: (res: any) => void,\n    overrideResponse?: any\n  ) => {\n    on(eventType, namespace, data => {\n      if (data !== null) {\n        off(namespace, eventType);\n        const response = overrideResponse ? overrideResponse : data;\n        callback(response);\n      }\n    });\n  };\n\n  const lastOfChildValue = async (namespace, key, value) => {\n    const snapshot = await deviceRef\n      .child(namespace)\n      .orderByChild(key)\n      .equalTo(value)\n      .limitToLast(1)\n      .once(\"value\");\n    const results = snapshot.val();\n    const [match] = Object.values(results || {});\n    return match || null;\n  };\n\n  return {\n    set,\n    once,\n    update,\n    lastOfChildValue,\n    onNamespace: (namespace: string, callback: Function): Function => {\n      return on(\"value\", namespace, (data: any) => {\n        if (data !== null) {\n          callback(data);\n        }\n      });\n    },\n    offNamespace: (namespace: string, listener: Function): void => {\n      off(namespace, \"value\", listener);\n    },\n    dispatchAction: async action => {\n      const snapshot = await push(\"actions\", action);\n      const actionId = snapshot.key;\n      const actionPath = `actions/${actionId}`;\n\n      snapshot.onDisconnect().remove();\n\n      if (action.responseRequired) {\n        const responseTimeout = action.responseTimeout || 600000; // defaults to 10 minutes\n        const timeout = new Promise((_, reject) => {\n          const id = setTimeout(() => {\n            clearTimeout(id);\n            snapshot.remove();\n            reject(\n              `Action response timed out in ${responseTimeout}ms.`\n            );\n          }, responseTimeout);\n        });\n\n        const response = new Promise(resolve => {\n          bindListener(\"value\", `${actionPath}/response`, resolve);\n        });\n\n        return Promise.race([response, timeout]);\n      }\n\n      return actionId;\n    },\n    nextMetric: async (\n      metricName: string,\n      metricValue: { [label: string]: any }\n    ) => {\n      set(`metrics/${metricName}`, metricValue);\n    },\n    onMetric: (subscription, callback: Function) => {\n      const { atomic, metric, labels } = subscription;\n      const child = atomic\n        ? `metrics/${metric}`\n        : `metrics/${metric}/${labels[0]}`;\n      return on(\"value\", child, data => {\n        if (data !== null) {\n          callback(data);\n        }\n      });\n    },\n    subscribeToMetric: subscription => {\n      const id = deviceRef.child(\"subscriptions\").push().key;\n      const childPath = `subscriptions/${id}`;\n      const subscriptionCreated = {\n        id,\n        clientId,\n        ...subscription\n      };\n      set(childPath, subscriptionCreated);\n\n      deviceRef\n        .child(childPath)\n        .onDisconnect()\n        .remove();\n\n      return subscriptionCreated;\n    },\n    unsubscribFromMetric: (subscription, listener: Function) => {\n      off(\"value\", listener);\n      remove(`subscriptions/${subscription.id}`);\n    }\n  };\n};\n","import { Observable } from \"rxjs\";\nimport firebase from \"firebase/app\";\nimport \"firebase/database\";\nimport \"firebase/functions\";\nimport \"firebase/auth\";\n\nimport { User } from \"@firebase/auth-types\";\n\nimport { config } from \"./config\";\nimport { createDeviceStore } from \"./deviceStore\";\nimport { NotionOptions } from \"../../types/options\";\nimport { Credentials } from \"../../types/credentials\";\n\nconst SERVER_TIMESTAMP = firebase.database.ServerValue.TIMESTAMP;\n\n/**\n * @hidden\n */\nexport const credentialWithLink: Function =\n  firebase.auth.EmailAuthProvider.credentialWithLink;\n\n/**\n * @hidden\n */\nexport function createUser(...args) {\n  return new (firebase as any).User(...args);\n}\n\n/**\n * @hidden\n */\nexport class FirebaseClient {\n  public serverType = \"firebase\";\n  protected standalone: boolean;\n  protected app;\n  protected deviceStore;\n  public user: User | null;\n\n  constructor(options: NotionOptions) {\n    this.init(options);\n  }\n\n  private init(options: NotionOptions) {\n    this.app = this.getApp(options.deviceId);\n    this.standalone = this.app.name === options.deviceId;\n    this.deviceStore = createDeviceStore(\n      this.app,\n      options.deviceId,\n      SERVER_TIMESTAMP\n    );\n\n    this.app.auth().onAuthStateChanged((user: User | null) => {\n      this.user = user;\n    });\n  }\n\n  public auth() {\n    return this.app.auth();\n  }\n\n  onAuthStateChanged(): Observable<User | null> {\n    return new Observable(observer => {\n      this.app.auth().onAuthStateChanged((user: User | null) => {\n        observer.next(user);\n      });\n    });\n  }\n\n  onLogin(): Observable<User> {\n    return new Observable(observer => {\n      const unsubscribe = this.app\n        .auth()\n        .onAuthStateChanged((user: User) => {\n          if (!!user) {\n            observer.next(user);\n            observer.complete();\n          }\n        });\n      return () => unsubscribe();\n    });\n  }\n\n  login(credentials: Credentials) {\n    if (\"idToken\" in credentials && \"providerId\" in credentials) {\n      const provider = new firebase.auth.OAuthProvider(\n        credentials.providerId\n      );\n      const oAuthCredential = provider.credential(credentials.idToken);\n      return this.app.auth().signInWithCredential(oAuthCredential);\n    }\n\n    if (\"email\" in credentials && \"password\" in credentials) {\n      const { email, password } = credentials;\n      return this.app\n        .auth()\n        .signInWithEmailAndPassword(email, password);\n    }\n\n    throw new Error(\n      `Either email/password or an idToken/providerId is required`\n    );\n  }\n\n  logout() {\n    return this.app.auth().signOut();\n  }\n\n  private getApp(deviceId: string) {\n    const notionAppName = deviceId;\n    const moduleApps = firebase.apps;\n    const browserApps =\n      typeof window !== \"undefined\" &&\n      \"firebase\" in window &&\n      \"apps\" in window.firebase\n        ? window.firebase.apps\n        : [];\n\n    const neurosityApp = [...moduleApps, ...browserApps].find(\n      (app: any) =>\n        app.name === \"[DEFAULT]\" &&\n        app.options.databaseURL === config.databaseURL\n    );\n\n    if (neurosityApp) {\n      return neurosityApp;\n    }\n\n    const notionApp = moduleApps.find(\n      app => app.name === notionAppName\n    );\n    return notionApp\n      ? notionApp\n      : firebase.initializeApp(config, notionAppName);\n  }\n\n  public dispatchAction(action): Promise<any> {\n    return this.deviceStore.dispatchAction(action);\n  }\n\n  public async getInfo(): Promise<any> {\n    return await this.deviceStore.once(\"info\");\n  }\n\n  public async getSkill(bundleId): Promise<any> {\n    return await this.deviceStore.lastOfChildValue(\n      \"skills\",\n      \"bundleId\",\n      bundleId\n    );\n  }\n\n  public onNamespace(namespace: string, callback: Function): Function {\n    return this.deviceStore.onNamespace(namespace, callback);\n  }\n\n  public offNamespace(namespace: string, listener: Function): void {\n    this.deviceStore.offNamespace(namespace, listener);\n  }\n\n  public async getTimesync(): Promise<number> {\n    const response = await this.dispatchAction({\n      command: \"timesync\",\n      action: \"get\",\n      responseRequired: true,\n      responseTimeout: 250\n    });\n    return response.timestamp;\n  }\n\n  public httpsCallable(functionName: string, data: object) {\n    return this.app.functions().httpsCallable(functionName)(data);\n  }\n\n  /**\n   * Pushes metric for each subscriptions in path:\n   * /devices/:deviceId/metrics/:metricName\n   */\n  public nextMetric(\n    metricName: string,\n    metricValue: { [label: string]: any }\n  ): void {\n    this.deviceStore.nextMetric(metricName, metricValue);\n  }\n\n  /**\n   * Listens for metrics in path:\n   * /devices/:deviceId/metrics/:metricName\n   */\n  public onMetric(subscription, callback): void {\n    this.deviceStore.onMetric(subscription, callback);\n  }\n\n  /**\n   * Creates a new and unique subscription in path:\n   * /devices/:deviceId/subscriptions/:subscriptionId\n   * E.g. /devices/device1/subscriptions/subscription3\n   *\n   * @param subscription\n   * @returns subscriptionId\n   */\n  public subscribeToMetric(subscription) {\n    const subscriptionId = this.deviceStore.subscribeToMetric(\n      subscription\n    );\n    return subscriptionId;\n  }\n\n  /**\n   * Removes subscription in path:\n   * /devices/:deviceId/subscriptions/:subscriptionId\n   *\n   * @param metric\n   * @param subscriptionId\n   */\n  public unsubscribFromMetric(subscription, listener: Function): void {\n    this.deviceStore.unsubscribFromMetric(subscription, listener);\n  }\n\n  public get timestamp(): any {\n    return SERVER_TIMESTAMP;\n  }\n\n  public async changeSettings(settings): Promise<void> {\n    return this.deviceStore.update(\"settings\", settings);\n  }\n\n  public disconnect(): Promise<any> {\n    if (this.standalone) {\n      return this.app.delete();\n    }\n    return Promise.resolve();\n  }\n}\n","import io from \"socket.io-client\";\n\n/**\n * @hidden\n */\nexport class WebsocketClient {\n  public serverType: string = \"websocket\";\n  protected socket;\n  options;\n\n  constructor(options) {\n    this.socket = io(options.socketUrl, {\n      path: `/${options.deviceId}`\n    });\n\n    this.init();\n  }\n\n  public onMetric(subscription, callback) {\n    return this.socket.on(`metrics/${subscription.id}`, callback);\n  }\n\n  private init(): void {\n    if (!this.socket.connected) {\n      this.socket.connect();\n    }\n  }\n\n  public disconnect(): void {\n    if (this.socket.connected) {\n      this.socket.disconnect();\n    }\n  }\n}\n","import { timer, pipe, range } from \"rxjs\";\nimport { map, concat } from \"rxjs/operators\";\nimport { bufferCount, concatMap } from \"rxjs/operators\";\nimport outliers from \"outliers\";\n\ntype Options = {\n  getTimesync: () => Promise<number>;\n  bufferSize?: number;\n  updateInterval?: number;\n};\n\nconst defaultOptions = {\n  bufferSize: 100,\n  updateInterval: 1 * 60 * 1000 // every minute\n};\n\nexport class Timesync {\n  options: Options;\n  _offset: number = 0;\n\n  constructor(options: Options) {\n    this.options = {\n      ...defaultOptions,\n      ...options\n    };\n\n    this.starTimer();\n  }\n\n  private starTimer(): void {\n    const { bufferSize, updateInterval } = this.options;\n    const burst$ = range(0, bufferSize);\n    const timer$ = timer(updateInterval, updateInterval).pipe(\n      map(i => bufferSize + i)\n    );\n\n    burst$\n      .pipe(\n        concat(timer$),\n        this.toOffset(),\n        bufferCount(bufferSize, 1),\n        this.filterOutliers(),\n        map(list => this.average(list))\n      )\n      .subscribe(offset => {\n        this._offset = offset;\n      });\n  }\n\n  filterOutliers() {\n    return pipe(\n      map((offsets: number[]): number[] => {\n        return offsets.filter(outliers());\n      })\n    );\n  }\n\n  toOffset() {\n    const { getTimesync } = this.options;\n    return pipe(\n      concatMap(async () => {\n        const requestStartTime = Date.now();\n        const [error, serverTime] = await getTimesync()\n          .then(offset => [null, offset])\n          .catch(error => [error]);\n\n        if (error) {\n          console.log(error);\n          return 0;\n        }\n\n        const responseEndtime = Date.now();\n        const oneWayDuration = (responseEndtime - requestStartTime) / 2;\n        const offset = responseEndtime - oneWayDuration - serverTime;\n        return offset;\n      })\n    );\n  }\n\n  private average(list: number[]): number {\n    return Math.round(\n      list.reduce((acc, number) => acc + number) / list.length\n    );\n  }\n\n  public get offset(): number {\n    return this._offset;\n  }\n\n  public get timestamp(): number {\n    return Date.now() + this._offset;\n  }\n}\n","export * from \"./Timesync\";\n","import { metrics } from \"@neurosity/ipk\";\nimport { FirebaseClient } from \"./firebase/index\";\nimport { WebsocketClient } from \"./websocket\";\nimport { Timesync } from \"../timesync\";\nimport { Client } from \"../types/client\";\nimport { Actions } from \"../types/actions\";\nimport { Metrics } from \"../types/metrics\";\nimport { NotionOptions } from \"../types/options\";\nimport { SkillsClient, DeviceSkill } from \"../types/skill\";\nimport { Credentials } from \"../types/credentials\";\nimport { ChangeSettings } from \"../types/settings\";\n\nconst isNotionMetric = (metric: string): boolean =>\n  Object.keys(metrics).includes(metric);\n\nexport { credentialWithLink, createUser } from \"./firebase\";\n\n/**\n * @hidden\n */\nexport class ApiClient implements Client {\n  public user;\n  protected options: NotionOptions;\n  protected firebase: FirebaseClient;\n  protected onDeviceSocket: WebsocketClient;\n  protected timesync: Timesync;\n\n  constructor(options: NotionOptions) {\n    this.options = options;\n    this.firebase = new FirebaseClient(options);\n\n    this.firebase.onAuthStateChanged().subscribe(user => {\n      this.user = user;\n    });\n\n    if (this.options.timesync) {\n      this.firebase.onLogin().subscribe(() => {\n        this.timesync = new Timesync({\n          getTimesync: this.firebase.getTimesync.bind(this.firebase)\n        });\n      });\n    }\n\n    if (options.onDeviceSocketUrl) {\n      this.onDeviceSocket = new WebsocketClient({\n        deviceId: options.deviceId,\n        socketUrl: options.onDeviceSocketUrl\n      });\n    }\n  }\n\n  public get actions(): Actions {\n    return {\n      dispatch: action => {\n        return this.firebase.dispatchAction(action);\n      }\n    };\n  }\n\n  public async disconnect(): Promise<any> {\n    if (this.onDeviceSocket) {\n      this.onDeviceSocket.disconnect();\n    }\n    return this.firebase.disconnect();\n  }\n\n  public async getInfo(): Promise<any> {\n    return await this.firebase.getInfo();\n  }\n\n  public async login(credentials: Credentials): Promise<any> {\n    const user = await this.firebase.login(credentials);\n    return user;\n  }\n\n  public async logout(): Promise<any> {\n    return await this.firebase.logout();\n  }\n\n  public auth() {\n    return this.firebase.auth();\n  }\n\n  public onAuthStateChanged() {\n    return this.firebase.onAuthStateChanged();\n  }\n\n  public onNamespace(namespace: string, callback: Function): Function {\n    return this.firebase.onNamespace(namespace, callback);\n  }\n\n  public offNamespace(namespace: string, listener: Function): void {\n    this.firebase.offNamespace(namespace, listener);\n  }\n\n  public get metrics(): Metrics {\n    const shouldRerouteToDevice = (metric: string): boolean =>\n      this.onDeviceSocket && isNotionMetric(metric);\n    return {\n      next: (metricName, metricValue): void => {\n        this.firebase.nextMetric(metricName, metricValue);\n      },\n      on: (subscription, callback) => {\n        if (shouldRerouteToDevice(subscription.metric)) {\n          return this.onDeviceSocket.onMetric(subscription, callback);\n        } else {\n          return this.firebase.onMetric(subscription, callback);\n        }\n      },\n      subscribe: subscription => {\n        const serverType = shouldRerouteToDevice(subscription.metric)\n          ? this.onDeviceSocket.serverType\n          : this.firebase.serverType;\n\n        const subscriptionCreated = this.firebase.subscribeToMetric({\n          ...subscription,\n          serverType\n        });\n        return subscriptionCreated;\n      },\n      unsubscribe: (subscription, listener): void => {\n        this.firebase.unsubscribFromMetric(subscription, listener);\n      }\n    };\n  }\n\n  public httpsCallable(functionName: string, data: object) {\n    return this.firebase.httpsCallable(functionName, data);\n  }\n\n  public get skills(): SkillsClient {\n    return {\n      get: async (bundleId: string): Promise<DeviceSkill> => {\n        return this.firebase.getSkill(bundleId);\n      }\n    };\n  }\n\n  public get timestamp(): number {\n    return this.options.timesync ? this.timesync.timestamp : Date.now();\n  }\n\n  public changeSettings(settings: ChangeSettings): Promise<void> {\n    return this.firebase.changeSettings(settings);\n  }\n}\n","import { metrics } from \"@neurosity/ipk\";\nimport { NotionOptions } from \"../types/options\";\n\nexport const getLabels = (metric: string): string[] =>\n  Object.keys(metrics[metric]);\n\nexport const hasInvalidLabels = (\n  metric: string,\n  labels: string[]\n): boolean => {\n  const validLabels = getLabels(metric);\n  return !labels.every(label => validLabels.includes(label));\n};\n\nexport const isMetricDisallowed = (\n  metricName: string,\n  options: NotionOptions\n): boolean =>\n  \"skill\" in options &&\n  \"metrics\" in options.skill &&\n  !options.skill.metrics.includes(metricName);\n\nexport const validate = (\n  metric: string,\n  labels: string[],\n  options: NotionOptions\n): Error | false => {\n  const validLabels = getLabels(metric).join(\", \");\n\n  if (!labels.length) {\n    return new Error(\n      `At least one label is required for ${metric} metric. Please add one of the following labels: ${validLabels}`\n    );\n  }\n\n  if (isMetricDisallowed(metric, options)) {\n    return new Error(\n      `No permission to access the ${metric} metric. To access this metric, edit the skill's permissions`\n    );\n  }\n\n  if (hasInvalidLabels(metric, labels)) {\n    return new Error(\n      `One ore more labels provided to ${metric} are invalid. The valid labels for ${metric} are ${validLabels}`\n    );\n  }\n\n  return false;\n};\n","import { Observable, throwError, timer } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { ApiClient, credentialWithLink, createUser } from \"./api/index\";\nimport { getLabels, validate } from \"./utils/subscription\";\nimport { NotionOptions } from \"./types/options\";\nimport { Subscription } from \"./types/subscription\";\nimport { Training } from \"./types/training\";\nimport { SkillInstance } from \"./types/skill\";\nimport { Credentials } from \"./types/credentials\";\nimport { Settings, ChangeSettings } from \"./types/settings\";\nimport { AwarenessLabels } from \"./types/awareness\";\nimport { SignalQuality } from \"./types/signalQuality\";\nimport { Kinesis } from \"./types/kinesis\";\nimport { Calm } from \"./types/calm\";\nimport { Focus } from \"./types/focus\";\nimport {\n  BrainwavesLabel,\n  Epoch,\n  PowerByBand,\n  PSD\n} from \"./types/brainwaves\";\nimport { DeviceInfo } from \"./types/info\";\nimport { DeviceStatus } from \"./types/status\";\nimport { Action } from \"./types/actions\";\n\n/**\n * Example\n * ```typescript\n * import { Notion } from \"@neurosity/notion\";\n *\n * const notion = new Notion({\n *   deviceId: \"...\"\n * });\n * ```\n */\nexport class Notion {\n  /**\n   * @hidden\n   */\n  protected options: NotionOptions;\n\n  /**\n   * @hidden\n   */\n  protected api: ApiClient;\n\n  /**\n   *\n   * @hidden\n   */\n  static credentialWithLink = credentialWithLink;\n\n  /**\n   *\n   * @hidden\n   */\n  static createUser = createUser;\n\n  /**\n   * Creates new instance of Notion\n   * \n   * ```typescript\n   * const notion = new Notion({\n   *   deviceId: \"...\"\n   * });\n   * ```\n\n   * @param options\n   */\n  constructor(options: NotionOptions) {\n    this.options = Object.freeze(options);\n    this.api = new ApiClient(this.options);\n\n    if (!this.options.deviceId) {\n      throw new Error(\"Notion: deviceId is mandatory\");\n    }\n  }\n\n  /**\n   * Starts user session\n   *\n   * ```typescript\n   * await notion.login({\n   *   email: \"...\",\n   *   password: \"...\"\n   * });\n   * ```\n   *\n   * @param credentials\n   */\n  public async login(credentials: Credentials): Promise<void> {\n    return await this.api.login(credentials);\n  }\n\n  /**\n   * Ends user session\n   *\n   * ```typescript\n   * await notion.logout();\n   * // session has ended\n   * ```\n   *\n   */\n  public async logout(): Promise<void> {\n    return await this.api.logout();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public auth() {\n    return this.api.auth();\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   */\n  public onAuthStateChanged(): Observable<any> {\n    return this.api.onAuthStateChanged();\n  }\n\n  /**\n   * ```typescript\n   * const info = await notion.getInfo();\n   * ```\n   */\n  public async getInfo(): Promise<DeviceInfo> {\n    return await this.api.getInfo();\n  }\n\n  /**\n   * Ends database connection\n   *\n   * ```typescript\n   * await notion.disconnect();\n   * ```\n   */\n  public async disconnect(): Promise<void> {\n    return await this.api.disconnect();\n  }\n\n  /**\n   * @internal\n   * Not user facing\n   */\n  protected getMetric = (\n    subscription: Subscription\n  ): Observable<any> => {\n    const { metric, labels, atomic } = subscription;\n\n    const error = validate(metric, labels, this.options);\n    if (error) {\n      return throwError(error);\n    }\n\n    return new Observable(observer => {\n      const subscriptions: Subscription[] = atomic\n        ? [\n            this.api.metrics.subscribe({\n              metric: metric,\n              labels: labels,\n              atomic: atomic\n            })\n          ]\n        : labels.map(label => {\n            return this.api.metrics.subscribe({\n              metric: metric,\n              labels: [label],\n              atomic: atomic\n            });\n          });\n\n      const subscriptionWithListeners = subscriptions.map(\n        subscription => ({\n          subscription,\n          listener: this.api.metrics.on(\n            subscription,\n            (...data: any) => {\n              observer.next(...data);\n            }\n          )\n        })\n      );\n\n      return () => {\n        subscriptionWithListeners.forEach(\n          ({ subscription, listener }) => {\n            this.api.metrics.unsubscribe(subscription, listener);\n          }\n        );\n      };\n    });\n  };\n\n  /**\n   * @internal\n   * Not user facing\n   */\n  private dispatchAction(action: Action): Promise<Action> | void {\n    return this.api.actions.dispatch(action);\n  }\n\n  /**\n   * Injects an EEG marker to data stream\n   *\n   * ```typescript\n   * notion.addMarker(\"eyes-closed\");\n   *\n   * // later...\n   *\n   * notion.addMarker(\"eyes-open\");\n   * ```\n   *\n   * @param label Name the label to inject\n   */\n  public addMarker(label: string): void {\n    if (!label) {\n      throw new Error(\"Notion: a label is required for addMarker\");\n    }\n\n    this.dispatchAction({\n      command: \"marker\",\n      action: \"add\",\n      message: {\n        label,\n        timestamp: this.api.timestamp\n      }\n    });\n  }\n\n  /**\n   * @internal\n   *\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of awareness metric events\n   */\n  public awareness(\n    label: AwarenessLabels,\n    ...otherLabels: AwarenessLabels[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"awareness\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   *\n   * Example\n   * ```typescript\n   * notion.brainwaves(\"raw\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * Example\n   * ```typescript\n   * notion.brainwaves(\"powerByBand\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * Example\n   * ```typescript\n   * notion.brainwaves(\"psd\").subscribe(brainwaves => {\n   *   console.log(brainwaves);\n   * });\n   * ```\n   *\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of brainwaves metric events\n   */\n  public brainwaves(\n    label: BrainwavesLabel,\n    ...otherLabels: BrainwavesLabel[]\n  ): Observable<Epoch | PowerByBand | PSD> {\n    return this.getMetric({\n      metric: \"brainwaves\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Example\n   * ```typescript\n   * notion.calm().subscribe(calm => {\n   *   console.log(calm.probability);\n   * });\n   *\n   * // 0.45\n   * // 0.47\n   * // 0.53\n   * // 0.51\n   * // ...\n   * ```\n   *\n   * @returns Observable of calm events - awareness/calm alias\n   */\n  public calm(): Observable<Calm> {\n    return this.awareness(\"calm\");\n  }\n\n  /**\n   * Observes signal quality data where each property is the name\n   * of the channel and the value includes the standard deviation and\n   * a status set by the device\n   *\n   * ```typescript\n   * notion.signalQuality().subscribe(signalQuality => {\n   *   console.log(signalQuality);\n   * });\n   *\n   * // { FC6: { standardDeviation: 3.5, status: \"good\" }, C3: {...}, ... }\n   * ```\n   *\n   * @returns Observable of signalQuality metric events\n   */\n  public signalQuality(): Observable<SignalQuality> {\n    const metric = \"signalQuality\";\n    return this.getMetric({\n      metric,\n      labels: getLabels(metric),\n      atomic: true\n    });\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for `emotion` - Not user facing yet\n   *\n   * @returns Observable of emotion metric events\n   */\n  public emotion(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"emotion\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Observes last state of `settings` and all subsequent `settings` changes\n   *\n   * ```typescript\n   * notion.settings().subscribe(settings => {\n   *   console.log(settings.lsl);\n   * });\n   *\n   * // true\n   * // ...\n   * ```\n   *\n   * @returns Observable of `settings` metric events\n   */\n  public settings(): Observable<Settings> {\n    const namespace = \"settings\";\n    return new Observable(observer => {\n      const listener = this.api.onNamespace(\n        namespace,\n        (settings: Settings) => {\n          observer.next(settings);\n        }\n      );\n\n      return () => this.api.offNamespace(namespace, listener);\n    });\n  }\n\n  /**\n   * Example\n   * ```typescript\n   * notion.focus().subscribe(focus => {\n   *   console.log(focus.probability);\n   * });\n   *\n   * // 0.56\n   * // 0.46\n   * // 0.31\n   * // 0.39\n   * // ...\n   * ```\n   *\n   * @returns Observable of focus events - awareness/focus alias\n   */\n  public focus(): Observable<Focus> {\n    return this.awareness(\"focus\");\n  }\n\n  /**\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of kinesis metric events\n   */\n  public kinesis(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<Kinesis> {\n    return this.getMetric({\n      metric: \"kinesis\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * @param labels Name of metric properties to filter by\n   * @returns Observable of predictions metric events\n   */\n  public predictions(\n    label: string,\n    ...otherLabels: string[]\n  ): Observable<any> {\n    return this.getMetric({\n      metric: \"predictions\",\n      labels: label ? [label, ...otherLabels] : [],\n      atomic: false\n    });\n  }\n\n  /**\n   * Observes last state of `status` and all subsequent `status` changes\n   *\n   * ```typescript\n   * notion.status().subscribe(status => {\n   *   console.log(status.state);\n   * });\n   *\n   * // \"online\"\n   * // ...\n   * ```\n   *\n   * @returns Observable of `status` metric events\n   */\n  public status(): Observable<DeviceStatus> {\n    const namespace = \"status\";\n    const updateStatusInterval = 1000;\n\n    return new Observable(observer => {\n      const updateStatusSubscription = timer(\n        0,\n        updateStatusInterval\n      ).subscribe(i => {\n        this.api\n          .httpsCallable(\"updateDeviceStatus\", {\n            deviceId: this.options.deviceId\n          })\n          .catch(console.error);\n      });\n\n      const listener = this.api.onNamespace(namespace, status => {\n        observer.next(status);\n      });\n\n      return () => {\n        updateStatusSubscription.unsubscribe();\n        this.api.offNamespace(namespace, listener);\n      };\n    });\n  }\n\n  /**\n   * @internal\n   * Not user facing yet\n   *\n   * Changes device settings programatically. These settings can be\n   * also changed from the developer console under device settings.\n   *\n   * Available settings [[ChangeSettings]]\n   *\n   * Example\n   * ```typescript\n   * notion.changeSettings({\n   *   lsl: true\n   * });\n   * ```\n   */\n  public changeSettings(settings: ChangeSettings): Promise<void> {\n    return this.api.changeSettings(settings);\n  }\n\n  /**\n   *\n   * ```typescript\n   * notion.training.record({\n   *   metric: \"kinesis\",\n   *   label: \"push\"\n   * });\n   *\n   * notion.training.stop({\n   *   metric: \"kinesis\",\n   *   label: \"push\"\n   * });\n   * ```\n   *\n   * @returns Training methods\n   */\n  public get training(): Training {\n    return {\n      /**\n       * Records a training for a metric/label pair\n       * @category Training\n       */\n      record: training => {\n        const userId =\n          this.api.user && \"uid\" in this.api.user\n            ? this.api.user.uid\n            : null;\n        const message = {\n          fit: false,\n          baseline: false,\n          timestamp: this.api.timestamp,\n          ...training,\n          userId\n        };\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"record\",\n          message\n        });\n      },\n      /**\n       * Stops the training for a metric/label pair\n       * @category Training\n       */\n      stop: training => {\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"stop\",\n          message: {\n            ...training\n          }\n        });\n      },\n      /**\n       * Stops all trainings\n       * @category Training\n       */\n      stopAll: () => {\n        this.api.actions.dispatch({\n          command: \"training\",\n          action: \"stopAll\",\n          message: {}\n        });\n      }\n    };\n  }\n\n  /**\n   * @internal\n   * Proof of Concept for Skills - Not user facing yet\n   *\n   * Accesses a skill by Bundle ID. Additionally, allows to observe\n   * and push skill metrics\n   *\n   * @param bundleId Bundle ID of skill\n   * @returns Skill isntance\n   */\n  public async skill(bundleId: string): Promise<SkillInstance> {\n    const skillData = await this.api.skills.get(bundleId);\n\n    if (skillData === null) {\n      return Promise.reject(\n        new Error(\n          `Access denied for: ${bundleId}. Make sure the skill is installed.`\n        )\n      );\n    }\n\n    return {\n      metric: (label: string) => {\n        const metricName = `skill~${skillData.id}~${label}`;\n        const subscription = new Observable(observer => {\n          const subscription: Subscription = this.api.metrics.subscribe(\n            {\n              metric: metricName,\n              labels: [label],\n              atomic: true\n            }\n          );\n\n          const listener = this.api.metrics.on(\n            subscription,\n            (...data: any) => {\n              observer.next(...data);\n            }\n          );\n\n          return () => {\n            this.api.metrics.unsubscribe(subscription, listener);\n          };\n        }).pipe(map(metric => metric[label]));\n\n        Object.defineProperty(subscription, \"next\", {\n          value: (metricValue: { [label: string]: any }): void => {\n            this.api.metrics.next(metricName, {\n              [label]: metricValue\n            });\n          }\n        });\n\n        return subscription;\n      }\n    };\n  }\n}\n","import { Notion } from \"../Notion\";\nimport { NotionOptions } from \"../types/options\";\nimport { Skill, SkillInstance } from \"../types/skill\";\n\nexport type NotionOnDevice = Omit<Notion, \"skill\">;\n\nexport interface OnDeviceOptions extends NotionOptions {\n  onDeviceSocketUrl: string;\n  skill: Skill;\n}\n\n/**\n * @internal\n */\nexport async function createNotionOnDevice(\n  options: OnDeviceOptions\n): Promise<[NotionOnDevice, SkillInstance]> {\n  const notion = new Notion(options);\n  const skill = {\n    ...(await notion.skill(options.skill.bundleId)),\n    props: \"props\" in options.skill ? options.skill.props : {}\n  };\n  delete notion.skill;\n  return [notion, skill];\n}\n","import {\n  createNotionOnDevice,\n  OnDeviceOptions,\n  NotionOnDevice\n} from \"./NotionOnDevice\";\nimport { SkillInstance, SkillSubscription } from \"../types/skill\";\n\ntype SkillApp = (\n  notion: NotionOnDevice,\n  skill: SkillInstance\n) => () => Promise<void>;\n\nexport function createSkill(app: SkillApp) {\n  return {\n    subscribe: async (\n      options: OnDeviceOptions\n    ): Promise<SkillSubscription> => {\n      const [notion, skill] = await createNotionOnDevice(options);\n      const teardown = app(notion, skill);\n\n      return {\n        unsubscribe: async () => {\n          await notion.disconnect();\n\n          if (teardown && \"then\" in teardown) {\n            const cleanUp: any = await teardown;\n            if (typeof cleanUp === \"function\") {\n              cleanUp();\n            }\n          }\n\n          if (typeof teardown === \"function\" && \"then\" in teardown()) {\n            return await teardown();\n          }\n\n          if (typeof teardown === \"function\") {\n            return teardown();\n          }\n\n          return teardown;\n        }\n      };\n    }\n  };\n}\n","export * from \"./createSkill\";\nexport * from \"./NotionOnDevice\";\n","export * from \"./Notion\";\nexport * from \"./skills\";\n"]}